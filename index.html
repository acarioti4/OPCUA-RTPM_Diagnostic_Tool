<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OPCUA-RTPM Diagnostic Tool</title>
  <style>
    :root {
      --container-bg: #ffffff;
      --text-primary: #333333;
      --text-muted: #666666;
      --results-bg: #f8f9fa;
      --log-bg: #e7f3ff;
      --log-border: #2196F3;
      --accent: #667eea;
      --bg: #f3f4f6;
      --shadow-accent: rgba(102, 126, 234, 0.35);
      --bg-image: none;
      --accent-2: #7ea2ff;
      --glass-bg: rgba(255,255,255,0.45);
      --glass-stroke: rgba(0,0,0,0.06);
      --glass-shadow: rgba(0, 0, 0, 0.30);
      --overlay-scrim: rgba(255,255,255,0.06);
    }

    /* HOLOGRAM LIGHT THEME - Star Wars Holographic Display */
    .theme-light {
      --container-bg: rgba(20, 40, 60, 0.95);
      --text-primary: #4da6ff; /* Holographic blue text */
      --text-muted: #66b3ff;
      --results-bg: rgba(30, 50, 70, 0.7);
      --log-bg: rgba(25, 45, 65, 0.6);
      --log-border: #4da6ff;
      --accent: #3dcc66; /* Darker green for buttons */
      --accent-2: #4dcc77;
      --bg: #1a2d3f; /* Darker blue background */
      --shadow-accent: rgba(61, 204, 102, 0.25); /* Reduced glow */
      --keyline: rgba(77, 166, 255, 0.2);
      --header-bg: linear-gradient(180deg, rgba(30, 50, 70, 0.85) 0%, rgba(20, 40, 60, 0.75) 100%);
      --bg-image: none;
      --glass-bg: rgba(30, 50, 70, 0.4);
      --glass-stroke: rgba(77, 166, 255, 0.25);
      --overlay-scrim: rgba(20, 40, 60, 0.2);
      --holo-glow: #4da6ff;
      --scanline-color: rgba(77, 166, 255, 0.02);
    }

    /* HOLOGRAM DARK THEME - Red on Slate Grey */
    .theme-dark {
      --container-bg: rgba(20, 25, 30, 0.95);
      --text-primary: #ff4444; /* Red holographic text */
      --text-muted: #ff6666;
      --results-bg: rgba(25, 30, 35, 0.7);
      --log-bg: rgba(20, 25, 30, 0.6);
      --log-border: #ff4444;
      --accent: #ff3333; /* Bright red */
      --accent-2: #ff5555;
      --bg: #151920; /* Darker slate grey background */
      --shadow-accent: rgba(255, 51, 51, 0.25); /* Reduced glow */
      --keyline: rgba(255, 68, 68, 0.2);
      --header-bg: linear-gradient(180deg, rgba(25, 30, 35, 0.85) 0%, rgba(20, 25, 30, 0.75) 100%);
      --bg-image: none;
      --glass-bg: rgba(25, 30, 35, 0.4);
      --glass-stroke: rgba(255, 68, 68, 0.25);
      --overlay-scrim: rgba(15, 20, 25, 0.3);
      --holo-glow: #ff4444;
      --scanline-color: rgba(255, 68, 68, 0.02);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', 'Consolas', monospace, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto;
      background: var(--bg);
      padding: 20px;
      min-height: 100vh;
      color: var(--text-primary);
      position: relative;
      text-shadow: 0 0 1px currentColor; /* Minimal text glow */
      /* Removed flicker animation for better performance */
      transform: translateZ(0); /* GPU acceleration */
    }


    /* Holographic scanline effect - Optimized: reduced frequency and opacity */
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: repeating-linear-gradient(
        0deg,
        var(--scanline-color) 0px,
        transparent 2px,
        transparent 4px,
        var(--scanline-color) 5px
      );
      z-index: 9999;
      pointer-events: none;
      animation: scanlineMove 12s linear infinite;
      will-change: transform;
      opacity: 0.3;
      transform: translateZ(0); /* GPU acceleration */
    }

    /* Holographic grid overlay - Optimized: simplified background */
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      z-index: -1;
      background: 
        radial-gradient(circle at 50% 50%, var(--holo-glow) 0%, transparent 70%);
      background-size: 100% 100%;
      opacity: 0.08;
      pointer-events: none;
      animation: gridPulse 6s ease-in-out infinite alternate;
      transform: translateZ(0); /* GPU acceleration */
    }

    /* Hologram flicker animation - Optimized: removed for better performance */
    @keyframes hologramFlicker {
      0%, 100% { opacity: 1; }
    }

    /* Scanline movement - Optimized: slower, less movement */
    @keyframes scanlineMove {
      0% { transform: translateY(0) translateZ(0); }
      100% { transform: translateY(2px) translateZ(0); }
    }

    /* Grid pulse effect - Optimized: reduced range */
    @keyframes gridPulse {
      0% { opacity: 0.08; }
      100% { opacity: 0.12; }
    }

    /* removed gradient animations to keep solid tones */

    .container {
      max-width: 850px;
      margin: 0 auto;
      background: var(--glass-bg);
      border-radius: 16px;
      box-shadow: 
        0 0 15px var(--holo-glow),
        0 0 30px var(--shadow-accent),
        inset 0 0 25px rgba(0, 255, 255, 0.02);
      border: 2px solid var(--glass-stroke);
      -webkit-backdrop-filter: saturate(140%) blur(16px);
      backdrop-filter: saturate(140%) blur(16px);
      overflow: hidden;
      position: relative;
      transform: translateZ(0); /* GPU acceleration */
      will-change: auto; /* Removed animation, no need for will-change */
    }


    .header {
      background: var(--header-bg);
      color: var(--text-primary);
      padding: 30px;
      text-align: center;
      position: relative;
      box-shadow: 0 8px 32px rgba(0,0,0,0.18);
      border-bottom: 1px solid var(--glass-stroke);
    }
    body.theme-dark .header { color: var(--text-primary); }


    .header h1 {
      font-size: 24px;
      margin-bottom: 5px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5); /* Minimal text glow */
      animation: none; /* Remove text glow animation */
      letter-spacing: 2px;
      font-weight: 700;
    }

    .header p {
      opacity: 0.95;
      font-size: 14px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5); /* Minimal text glow */
      letter-spacing: 1px;
    }


    .theme-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
    }

    .theme-chip {
      border: 2px solid var(--glass-stroke);
      border-radius: 9999px;
      padding: 6px 14px;
      font-weight: 700;
      font-size: 12px;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
      background: var(--glass-bg);
      -webkit-backdrop-filter: saturate(160%) blur(12px);
      backdrop-filter: saturate(160%) blur(12px);
      color: var(--text-primary);
      box-shadow: 
        0 0 10px var(--holo-glow),
        inset 0 0 15px rgba(0, 255, 255, 0.03);
      text-shadow: 0 1px 1px rgba(0,0,0,0.3); /* Minimal text glow */
      letter-spacing: 1px;
    }


    .theme-chip:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 
        0 0 18px var(--holo-glow),
        inset 0 0 20px rgba(0, 255, 255, 0.05);
    }

    .theme-chip.light.active {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #ffffff;
      border-color: var(--accent);
      box-shadow: 
        0 0 18px var(--accent),
        0 0 35px var(--shadow-accent),
        inset 0 0 20px rgba(255,255,255,0.25);
      text-shadow: 0 1px 2px rgba(0,0,0,0.5); /* Minimal text glow */
    }

    .theme-chip.dark.active {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #ffffff;
      border-color: var(--accent);
      box-shadow: 
        0 0 18px var(--accent),
        0 0 35px var(--shadow-accent),
        inset 0 0 20px rgba(255,255,255,0.25);
      text-shadow: 0 1px 2px rgba(0,0,0,0.5); /* Minimal text glow */
    }

    .content {
      padding: 30px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 700;
      color: var(--text-primary);
      font-size: 14px;
      text-shadow: 0 1px 1px rgba(0,0,0,0.3); /* Minimal text glow */
      letter-spacing: 0.5px;
    }

    input {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--glass-stroke);
      border-radius: 10px;
      font-size: 14px;
      font-family: 'Courier New', monospace;
      transition: border-color 0.15s ease-out, box-shadow 0.15s ease-out;
      background: var(--glass-bg);
      -webkit-backdrop-filter: saturate(130%) blur(6px);
      backdrop-filter: saturate(130%) blur(6px);
      color: var(--text-primary);
      caret-color: var(--accent);
      box-shadow: 
        0 0 2px var(--holo-glow),
        inset 0 0 12px rgba(0, 255, 255, 0.02);
      text-shadow: none;
      transform: translateZ(0); /* GPU acceleration */
    }

    input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 
        0 0 6px var(--holo-glow),
        0 0 12px var(--shadow-accent),
        inset 0 0 18px rgba(0, 255, 255, 0.05);
    }
    input::placeholder { 
      color: var(--text-muted);
      opacity: 0.6;
    }
    .btn:focus-visible, .theme-chip:focus-visible, input:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
      box-shadow: 
        0 0 8px var(--holo-glow),
        0 0 15px var(--shadow-accent);
    }
    body.theme-dark input {
      border-color: var(--glass-stroke);
      background: var(--glass-bg);
      color: var(--text-primary);
    }
    body.theme-dark input::placeholder { 
      color: var(--text-muted);
      opacity: 0.6;
    }
    body.theme-dark input:focus { 
      box-shadow: 
        0 0 6px var(--holo-glow),
        0 0 12px var(--shadow-accent),
        inset 0 0 20px rgba(255, 68, 68, 0.06);
    }

    /* Light theme input clarity */
    body.theme-light input {
      background: var(--glass-bg);
      border-color: var(--glass-stroke);
      color: var(--text-primary);
    }
    body.theme-light input::placeholder { 
      color: var(--text-muted);
      opacity: 0.6;
    }
    body.theme-light input:focus {
      box-shadow: 
        0 0 6px var(--holo-glow),
        0 0 12px var(--shadow-accent),
        inset 0 0 20px rgba(77, 166, 255, 0.06);
    }

    .port-range {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }

    .btn {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);
      color: #ffffff;
      border: 2px solid var(--accent);
      padding: 14px 28px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      width: 100%;
      transition: transform 0.12s ease-out, box-shadow 0.12s ease-out;
      box-shadow: 
        0 0 3px var(--accent),
        0 0 8px var(--shadow-accent),
        inset 0 0 12px rgba(255,255,255,0.2);
      position: relative;
      overflow: hidden;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      letter-spacing: 1.5px;
      transform: translateZ(0); /* GPU acceleration */
      /* Removed buttonPulse animation for better performance */
    }

    .btn::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0.0) 50%);
      mix-blend-mode: overlay;
      pointer-events: none;
    }

    .btn:hover:not(:disabled) {
      transform: translateY(-2px) scale(1.01) translateZ(0);
      box-shadow: 
        0 0 6px var(--accent),
        0 0 15px var(--shadow-accent),
        inset 0 0 20px rgba(255,255,255,0.25);
    }
    .btn:active:not(:disabled) {
      transform: translateY(-1px) scale(0.98);
      box-shadow: 
        0 0 5px var(--accent),
        0 0 12px var(--shadow-accent),
        inset 0 0 15px rgba(255,255,255,0.2);
    }

    /* Ripple effect for clicks (GPU-friendly transform + opacity) */
    .btn .ripple {
      position: absolute;
      border-radius: 9999px;
      transform: scale(0);
      background: rgba(255,255,255,0.35);
      pointer-events: none;
      will-change: transform, opacity;
      animation: ripple 450ms ease-out;
    }
    @keyframes ripple {
      to {
        transform: scale(4);
        opacity: 0;
      }
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* Determinate progress (0â€“100%) shown below the button */
    .run-progress {
      margin-top: 16px;
      display: none;
    }
    .progress-outer {
      height: 20px;
      background: var(--glass-bg);
      border-radius: 14px;
      overflow: hidden;
      border: 2px solid var(--glass-stroke);
      box-shadow: 
        0 0 10px var(--holo-glow),
        inset 0 0 15px rgba(0, 255, 255, 0.03);
      -webkit-backdrop-filter: blur(8px);
      backdrop-filter: blur(8px);
    }
    .progress-inner {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #9d4edd 0%, #c77dff 100%);
      box-shadow: 
        0 0 10px #9d4edd,
        0 0 20px rgba(157, 78, 221, 0.3),
        inset 0 0 12px rgba(255, 255, 255, 0.2);
      transform-origin: 0 50%;
      transform: scaleX(0) translateZ(0);
      transition: transform 80ms cubic-bezier(0.4, 0, 0.2, 1);
      will-change: transform;
      position: relative;
      overflow: hidden;
    }
    /* Removed progressShine animation for better performance */

    .progress-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 6px;
      font-size: 12px;
      color: var(--text-primary);
      text-shadow: 0 1px 1px rgba(0,0,0,0.3); /* Minimal text glow */
      font-weight: 600;
      letter-spacing: 0.5px;
    }
    .current-task {
      display: none;
      margin-top: 6px;
      font-size: 13px;
      color: var(--text-primary);
      text-shadow: 0 1px 1px rgba(0,0,0,0.3); /* Minimal text glow */
      font-weight: 600;
    }
    /* Jedi theme: subtle glow on the gradient split already added above */

    /* Button morphs into an inline progress bar while running */
    .btn.progressing {
      position: relative;
      transform: none !important;
      box-shadow: 
        0 0 20px var(--holo-glow),
        inset 0 0 30px rgba(0, 255, 255, 0.1);
      background: var(--glass-bg);
      color: transparent; /* hide label while progress is shown */
      animation: none;
    }
    .btn.progressing:hover {
      transform: none !important;
      box-shadow: 
        0 0 20px var(--holo-glow),
        inset 0 0 30px rgba(0, 255, 255, 0.1);
    }
    .inline-progress {
      height: 12px;
      width: 100%;
      background: var(--glass-bg);
      border-radius: 9999px;
      overflow: hidden;
      border: 1px solid var(--glass-stroke);
    }
    .inline-progress .bar {
      position: relative;
      height: 100%;
      width: 40%;
      left: -40%;
      border-radius: 9999px;
      background: linear-gradient(90deg, #9d4edd, #c77dff);
      box-shadow: 
        0 0 15px #9d4edd,
        0 0 25px rgba(157, 78, 221, 0.4);
      animation: indeterminateSweep 1.2s ease-in-out infinite;
      will-change: transform, left, width;
    }
    @keyframes indeterminateSweep {
      0%   { left: -40%; width: 40%; }
      50%  { left: 20%;  width: 60%; }
      100% { left: 100%; width: 40%; }
    }

    .results-section {
      margin-top: 30px;
      display: none;
    }

    .results-section.active {
      display: block;
    }

    .results-list {
      background: rgba(15, 20, 25, 0.7);
      -webkit-backdrop-filter: blur(12px);
      backdrop-filter: blur(12px);
      border-radius: 12px;
      padding: 20px;
      max-height: 300px;
      overflow-y: auto;
      border: 2px solid var(--glass-stroke);
      box-shadow: 
        0 0 10px var(--holo-glow),
        inset 0 0 20px rgba(0, 255, 255, 0.02);
    }
    .theme-light .results-list { 
      background: rgba(15, 25, 35, 0.8);
      box-shadow: 
        0 0 10px var(--holo-glow),
        inset 0 0 20px rgba(77, 166, 255, 0.02);
    }
    .theme-dark .results-list { 
      background: rgba(10, 15, 20, 0.85);
      box-shadow: 
        0 0 10px var(--holo-glow),
        inset 0 0 20px rgba(255, 68, 68, 0.02);
    }
    .category-title {
      margin: 14px 0 8px;
      font-weight: 800;
      font-size: 12px;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--text-primary);
      border-top: 2px solid var(--keyline);
      padding-top: 10px;
      text-shadow: 0 1px 1px rgba(0,0,0,0.3); /* Minimal text glow */
    }

    .result-item {
      padding: 12px;
      margin-bottom: 10px;
      border-radius: 10px;
      border-left: 4px solid;
      background: var(--glass-bg);
      -webkit-backdrop-filter: blur(6px);
      backdrop-filter: blur(6px);
      border: 2px solid var(--glass-stroke);
      border-left-width: 4px;
      animation: fadeSlideIn 200ms ease-out;
      box-shadow: 
        0 0 6px var(--holo-glow),
        inset 0 0 10px rgba(0, 255, 255, 0.012);
      transform: translateZ(0); /* GPU acceleration */
      will-change: opacity, transform;
    }
    .theme-light .result-item { 
      background: var(--glass-bg);
      box-shadow: 
        0 0 8px var(--holo-glow),
        inset 0 0 12px rgba(77, 166, 255, 0.015);
    }


    @keyframes fadeSlideIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .spinner {
      width: 18px;
      height: 18px;
      border: 3px solid transparent;
      border-top-color: var(--accent);
      border-right-color: var(--accent-2);
      border-radius: 50%;
      display: inline-block;
      animation: spin 0.8s linear infinite;
      margin-left: 8px;
      vertical-align: text-bottom;
      box-shadow: 0 0 10px var(--accent);
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.001ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.001ms !important;
        scroll-behavior: auto !important;
      }
      body::before,
      body::after {
        animation: none !important;
      }
    }

    .result-item.open { 
      border-left-color: #00ff88;
      box-shadow: 
        0 0 10px rgba(0, 255, 136, 0.25),
        inset 0 0 12px rgba(0, 255, 136, 0.02);
    }
    .result-item.closed { 
      border-left-color: #ff0055;
      box-shadow: 
        0 0 10px rgba(255, 0, 85, 0.25),
        inset 0 0 12px rgba(255, 0, 85, 0.02);
    }
    .result-item.timeout { 
      border-left-color: #ffaa00;
      box-shadow: 
        0 0 10px rgba(255, 170, 0, 0.25),
        inset 0 0 12px rgba(255, 170, 0, 0.02);
    }
    .result-item.warning { 
      border-left-color: #ffaa00;
      box-shadow: 
        0 0 10px rgba(255, 170, 0, 0.25),
        inset 0 0 12px rgba(255, 170, 0, 0.02);
    }

    .result-item strong {
      display: block;
      margin-bottom: 4px;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    .result-item span {
      font-size: 13px;
      color: var(--text-muted);
    }

    .result-item.open strong, .result-item.open span { 
      color: #00ff88;
      text-shadow: 0 1px 1px rgba(0,0,0,0.3); /* Minimal text glow */
    }
    .result-item.closed strong, .result-item.closed span { 
      color: #ff0055;
      text-shadow: 0 1px 1px rgba(0,0,0,0.3); /* Minimal text glow */
    }
    .result-item.timeout strong, .result-item.timeout span { 
      color: #ffaa00;
      text-shadow: 0 1px 1px rgba(0,0,0,0.3); /* Minimal text glow */
    }
    .result-item.warning strong, .result-item.warning span { 
      color: #ffaa00;
      text-shadow: 0 1px 1px rgba(0,0,0,0.3); /* Minimal text glow */
    }

    .log-info {
      margin-top: 20px;
      padding: 15px;
      background: var(--glass-bg);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      border: 2px solid var(--glass-stroke);
      border-radius: 12px;
      font-size: 14px;
      box-shadow: 
        0 0 10px var(--holo-glow),
        inset 0 0 18px rgba(0, 255, 255, 0.02);
    }

    .log-info strong {
      display: block;
      margin-bottom: 5px;
      color: var(--accent);
      text-shadow: 0 1px 1px rgba(0,0,0,0.3); /* Minimal text glow */
      letter-spacing: 0.5px;
      font-weight: 700;
    }

    /* About Modal */
    .about-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      backdrop-filter: blur(5px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 20px;
    }
    .about-overlay.active { display: flex; }
    .about-modal {
      background: var(--glass-bg);
      color: var(--text-primary);
      border-radius: 16px;
      padding: 24px;
      width: min(480px, 90vw);
      box-shadow: 
        0 0 25px var(--holo-glow),
        0 0 50px var(--shadow-accent),
        inset 0 0 35px rgba(0, 255, 255, 0.02);
      border: 2px solid var(--glass-stroke);
      -webkit-backdrop-filter: blur(16px);
      backdrop-filter: blur(16px);
      position: relative;
      animation: modalSlideIn 0.3s ease-out;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-30px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .about-title { 
      margin-bottom: 8px; 
      font-size: 18px; 
      font-weight: 800; 
      letter-spacing: 1px;
      text-shadow: 0 1px 1px rgba(0,0,0,0.3); /* Minimal text glow */
    }
    .about-body { 
      font-size: 14px; 
      color: var(--text-primary); 
      line-height: 1.6;
      text-shadow: none; /* Remove text glow */
    }
    .about-meta { 
      margin-top: 12px; 
      padding-top: 12px; 
      border-top: 2px solid var(--keyline);
      box-shadow: 0 2px 6px var(--holo-glow);
      display: grid; 
      row-gap: 6px;
    }
    .about-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: transparent;
      border: 2px solid transparent;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      font-size: 20px;
      cursor: pointer;
      color: var(--text-muted);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .about-close:hover { 
      color: var(--text-primary);
      border-color: var(--accent);
      background: var(--glass-bg);
      box-shadow: 
        0 0 12px var(--holo-glow),
        inset 0 0 15px rgba(0, 255, 255, 0.06);
      transform: rotate(90deg);
    }

    /* Themed repository link */
    .about-body a#aboutLink {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--accent);
      text-decoration: none;
      font-weight: 700;
      padding: 6px 10px;
      border-radius: 10px;
      background: var(--glass-bg);
      -webkit-backdrop-filter: blur(8px);
      backdrop-filter: blur(8px);
      border: 1px solid var(--glass-stroke);
      box-shadow: 0 4px 14px rgba(0,0,0,0.08) inset;
      overflow-wrap: anywhere;
    }
    .about-body a#aboutLink:hover {
      text-decoration: underline;
      box-shadow: 0 6px 18px var(--shadow-accent);
    }
    .about-body a#aboutLink:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    .about-body a#aboutLink::after {
      content: 'â†—';
      font-size: 12px;
      opacity: 0.8;
    }

    /* Reduced motion: already handled below */

    /* Holographic scrollbar styling */
    ::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }
    ::-webkit-scrollbar-track {
      background: var(--glass-bg);
      border-radius: 10px;
      box-shadow: inset 0 0 8px rgba(0, 255, 255, 0.06);
    }
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, #9d4edd, #c77dff);
      border-radius: 10px;
      border: 2px solid var(--glass-bg);
      box-shadow: 
        0 0 10px #9d4edd,
        inset 0 0 8px rgba(255, 255, 255, 0.15);
    }
    ::-webkit-scrollbar-thumb:hover {
      box-shadow: 
        0 0 18px #9d4edd,
        0 0 30px rgba(157, 78, 221, 0.4),
        inset 0 0 12px rgba(255, 255, 255, 0.25);
    }

    /* Backdrop-filter fallback for older GPUs/drivers */
    @supports not ((backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px))) {
      .container,
      .results-list,
      .result-item,
      .about-modal,
      .theme-chip,
      input,
      .progress-outer {
        background: var(--container-bg);
      }
      .btn { filter: saturate(110%); }
      body::after {
        background: linear-gradient(180deg, rgba(255,255,255,0.75) 0%, rgba(255,255,255,0.0) 40%);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>OPCUA-RTPM Diagnostic Tool</h1>
      <p>Connectivity and Callback Path Diagnostics</p>
      <!-- Settings are available in the native menu bar -->
    </div>

    <div class="content">
      <form id="probeForm">
        <div class="form-group">
          <label for="endpointUrl">OPC UA Endpoint URL</label>
          <input
            type="text"
            id="endpointUrl"
            placeholder="e.g., opc.tcp://192.168.1.50:4840"
            value="opc.tcp://127.0.0.1:4840"
            required
          >
        </div>
        <div class="port-range">
          <div class="form-group">
            <label for="systemBHost">System B IP (optional, for SYN filter)</label>
            <input
              type="text"
              id="systemBHost"
              placeholder="e.g., 192.168.1.60"
              pattern="^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$"
            >
          </div>
          <div class="form-group">
            <label for="synSeconds">SYN Monitor Seconds</label>
            <input
              type="number"
              id="synSeconds"
              min="0"
              max="120"
              value="10"
              required
            >
          </div>
        </div>
        <div class="port-range">
          <div class="form-group">
            <label for="nodeId">Monitored NodeId (optional)</label>
            <input
              type="text"
              id="nodeId"
              placeholder="ns=0;i=2258 (ServerStatus_CurrentTime)"
            >
          </div>
          <div class="form-group">
            <label for="pubInterval">Publishing Interval (ms)</label>
            <input
              type="number"
              id="pubInterval"
              min="50"
              max="10000"
              value="250"
              required
            >
          </div>
        </div>
        <button type="submit" class="btn" id="btnRunProbe">Run Callback Path Probe</button>
        <div class="run-progress" id="runProgress" aria-hidden="true">
          <div class="progress-outer" aria-label="Probe progress">
            <div class="progress-inner" id="progressInner"></div>
          </div>
          <div class="progress-meta">
            <span id="progressLabel">Preparingâ€¦</span>
            <span id="progressPercent">0%</span>
          </div>
          <div class="current-task" id="currentTaskWrapper">
            <span id="currentTaskText">Ready</span>
          </div>
        </div>
      </form>

      <div class="results-section" id="resultsSection">
        <div class="results-list" id="resultsList"></div>
        <div class="log-info" id="logInfo"></div>
      </div>
    </div>
  </div>

  <!-- About Modal -->
  <div class="about-overlay" id="aboutOverlay" aria-hidden="true">
    <div class="about-modal" role="dialog" aria-modal="true" aria-labelledby="aboutTitle">
      <button class="about-close" id="aboutClose" aria-label="Close About">&times;</button>
      <div class="about-title" id="aboutTitle">About</div>
      <div class="about-body">
        <div class="about-meta">
          <div><strong>Version:</strong> <span id="aboutVersion">-</span></div>
          <div>2025</div>
        </div>
        <div style="margin-top:10px;">
          <a href="https://github.com/acarioti4/OPCUA-RTPM_Diagnostic_Tool" id="aboutLink" rel="noopener noreferrer">github.com/acarioti4/OPCUA-RTPM_Diagnostic_Tool</a>
        </div>
      </div>
    </div>
  </div>

  <!-- Keybinds Modal -->
  <div class="about-overlay" id="keybindsOverlay" aria-hidden="true">
    <div class="about-modal" role="dialog" aria-modal="true" aria-labelledby="keybindsTitle">
      <button class="about-close" id="keybindsClose" aria-label="Close Keybinds">&times;</button>
      <div class="about-title" id="keybindsTitle">Keybinds</div>
      <div class="about-body">
        <div class="about-meta">
          <div><strong>Run Probe:</strong> Ctrl+Enter</div>
          <div><strong>Focus Endpoint URL:</strong> Ctrl+L</div>
          <div><strong>Toggle Show Current Task:</strong> Ctrl+T</div>
          <div><strong>Theme - Light:</strong> Ctrl+Alt+L</div>
          <div><strong>Theme - Dark:</strong> Ctrl+Alt+D</div>
          <div><strong>Help - Keybinds:</strong> Ctrl+/</div>
          <div><strong>Help - About:</strong> F1</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const aboutOverlay = document.getElementById('aboutOverlay');
    const aboutClose = document.getElementById('aboutClose');
    const aboutVersion = document.getElementById('aboutVersion');
    const keybindsOverlay = document.getElementById('keybindsOverlay');
    const keybindsClose = document.getElementById('keybindsClose');
    const resultsSection = document.getElementById('resultsSection');
    const resultsList = document.getElementById('resultsList');
    const logInfo = document.getElementById('logInfo');
    const probeForm = document.getElementById('probeForm');
    const btnRunProbe = document.getElementById('btnRunProbe');
    const runProgress = document.getElementById('runProgress');
    const progressInner = document.getElementById('progressInner');
    const progressLabel = document.getElementById('progressLabel');
    const progressPercent = document.getElementById('progressPercent');
    const currentTaskWrapper = document.getElementById('currentTaskWrapper');
    const currentTaskText = document.getElementById('currentTaskText');
    const toggleShowTask = document.getElementById('toggleShowTask');
    let btnOriginalHtml = '';

    // Theme handling with localStorage persistence (defaults to light)
    function applyTheme(theme) {
      document.body.classList.remove('theme-light', 'theme-dark');
      if (theme === 'dark') {
        document.body.classList.add('theme-dark');
      } else {
        document.body.classList.add('theme-light');
      }
      // Save theme preference to localStorage
      localStorage.setItem('opcRtpmTheme', theme);
    }
    // Load saved theme or default to light
    let savedTheme = localStorage.getItem('opcRtpmTheme');
    // If no saved theme or invalid, default to light
    if (savedTheme !== 'light' && savedTheme !== 'dark') {
      savedTheme = 'light';
      localStorage.setItem('opcRtpmTheme', 'light');
    }
    applyTheme(savedTheme);
    // Sync theme with native menu
    if (window.electronAPI && window.electronAPI.onThemeSet) {
      window.electronAPI.onThemeSet(({ theme } = {}) => {
        if (theme === 'light' || theme === 'dark') {
          applyTheme(theme);
        }
      });
    }
    // Send theme to main process to sync menu - call multiple times to ensure it's received
    if (window.electronAPI && window.electronAPI.themeReady) {
      // Send immediately
      window.electronAPI.themeReady({ theme: savedTheme });
      // Send after short delays to ensure menu is ready
      setTimeout(() => {
        window.electronAPI.themeReady({ theme: savedTheme });
      }, 100);
      setTimeout(() => {
        window.electronAPI.themeReady({ theme: savedTheme });
      }, 300);
    }

    // Settings: Show Current Task toggle (defaults to true)
    const savedShowTask = localStorage.getItem('opcRtpmShowTask');
    const showTask = savedShowTask === null ? true : savedShowTask === 'true'; // Default to true if not set
    if (toggleShowTask) {
      toggleShowTask.checked = showTask;
    }
    function applyShowTaskSetting(enabled) {
      localStorage.setItem('opcRtpmShowTask', enabled ? 'true' : 'false');
      currentTaskWrapper.style.display = enabled ? 'block' : 'none';
    }
    applyShowTaskSetting(showTask);
    if (toggleShowTask) {
      toggleShowTask.addEventListener('change', (e) => {
        applyShowTaskSetting(!!e.target.checked);
      });
    }
    // Sync with native menu
    if (window.electronAPI && window.electronAPI.onSettingsSet) {
      window.electronAPI.onSettingsSet(({ showTask } = {}) => {
        applyShowTaskSetting(!!showTask);
      });
    }
    if (window.electronAPI && window.electronAPI.settingsReady) {
      window.electronAPI.settingsReady({ showTask: showTask });
    }

    // Progress helpers - Optimized with throttling and cleanup
    let progressValue = 0;
    let progressTarget = 0;
    let progressRAF = null;
    let lastUpdateTime = 0;
    const PROGRESS_UPDATE_INTERVAL = 16; // ~60fps max
    
    function setProgress(value, label) {
      progressTarget = Math.max(0, Math.min(100, Number.isFinite(value) ? value : 0));
      const now = performance.now();
      
      // Throttle label updates
      if (label && progressLabel && (now - lastUpdateTime > 50 || progressTarget === 100)) {
        progressLabel.textContent = label;
        lastUpdateTime = now;
      }
      
      if (!progressRAF) {
        const step = (currentTime) => {
          // Throttle updates to ~60fps
          if (currentTime - lastUpdateTime < PROGRESS_UPDATE_INTERVAL && progressTarget !== 100) {
            progressRAF = requestAnimationFrame(step);
            return;
          }
          
          // Optimized easing: faster convergence
          const diff = progressTarget - progressValue;
          if (Math.abs(diff) < 0.1) {
            progressValue = progressTarget;
            if (progressInner) {
              progressInner.style.transform = 'scaleX(' + (progressTarget / 100) + ') translateZ(0)';
            }
            if (progressPercent) {
              progressPercent.textContent = String(Math.round(progressTarget)) + '%';
            }
            progressRAF = null;
            lastUpdateTime = currentTime;
            return;
          }
          
          // Use cubic easing for smoother animation
          progressValue += diff * 0.3;
          const clamped = Math.max(0, Math.min(100, progressValue));
          const scaled = clamped / 100;
          
          if (progressInner) {
            // Use transform3d for GPU acceleration
            progressInner.style.transform = 'scaleX(' + scaled + ') translateZ(0)';
          }
          if (progressPercent) {
            progressPercent.textContent = String(Math.round(clamped)) + '%';
          }
          
          lastUpdateTime = currentTime;
          progressRAF = requestAnimationFrame(step);
        };
        progressRAF = requestAnimationFrame(step);
      }
    }
    
    // Cleanup function for progress
    function cleanupProgress() {
      if (progressRAF) {
        cancelAnimationFrame(progressRAF);
        progressRAF = null;
      }
    }
    // Throttled task updates
    let taskUpdateTimeout = null;
    function setCurrentTask(text) {
      if (!currentTaskText) return;
      // Debounce task updates to avoid excessive DOM writes
      if (taskUpdateTimeout) {
        clearTimeout(taskUpdateTimeout);
      }
      taskUpdateTimeout = setTimeout(() => {
        if (currentTaskText) {
          currentTaskText.textContent = text || '';
        }
      }, 100);
    }
    
    function startProgressUI() {
      cleanupProgress(); // Clean up any existing progress
      setProgress(0, 'Startingâ€¦');
      setCurrentTask('Initializing probeâ€¦');
      if (runProgress) {
        runProgress.style.display = 'block';
        runProgress.setAttribute('aria-hidden', 'false');
      }
      if (btnRunProbe) {
        btnOriginalHtml = btnRunProbe.innerHTML;
        btnRunProbe.classList.add('progressing');
        btnRunProbe.innerHTML = '<div class="inline-progress"><div class="bar"></div></div>';
      }
    }
    
    function stopProgressUI() {
      cleanupProgress();
      if (taskUpdateTimeout) {
        clearTimeout(taskUpdateTimeout);
        taskUpdateTimeout = null;
      }
    }

    // Live progress from backend
    if (window.electronAPI && window.electronAPI.onProbeProgress) {
      window.electronAPI.onProbeProgress(({ percent, label, task }) => {
        if (typeof percent === 'number') setProgress(percent, label);
        if (typeof task === 'string') setCurrentTask(task);
      });
    }

    // About handlers
    function showAbout(version) {
      if (aboutVersion) aboutVersion.textContent = version || '';
      aboutOverlay.classList.add('active');
      aboutOverlay.setAttribute('aria-hidden', 'false');
    }
    function hideAbout() {
      aboutOverlay.classList.remove('active');
      aboutOverlay.setAttribute('aria-hidden', 'true');
    }
    function showKeybinds() {
      keybindsOverlay.classList.add('active');
      keybindsOverlay.setAttribute('aria-hidden', 'false');
    }
    function hideKeybinds() {
      keybindsOverlay.classList.remove('active');
      keybindsOverlay.setAttribute('aria-hidden', 'true');
    }
    if (window.electronAPI && window.electronAPI.onShowAbout) {
      window.electronAPI.onShowAbout(({ version } = {}) => {
        showAbout(version);
      });
    }
    if (window.electronAPI && window.electronAPI.onShowKeybinds) {
      window.electronAPI.onShowKeybinds(() => {
        showKeybinds();
      });
    }
    aboutClose.addEventListener('click', hideAbout);
    const aboutLink = document.getElementById('aboutLink');
    if (aboutLink) {
      aboutLink.addEventListener('click', (e) => {
        e.preventDefault();
        if (window.electronAPI && window.electronAPI.openExternal) {
          window.electronAPI.openExternal('https://github.com/acarioti4/OPCUA-RTPM_Diagnostic_Tool');
        }
      });
    }

    // Lightweight click ripple for buttons
    function attachRipple(el) {
      if (!el) return;
      el.addEventListener('click', (e) => {
        const rect = el.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        const span = document.createElement('span');
        span.className = 'ripple';
        span.style.width = size + 'px';
        span.style.height = size + 'px';
        span.style.left = (e.clientX - rect.left - size / 2) + 'px';
        span.style.top = (e.clientY - rect.top - size / 2) + 'px';
        el.appendChild(span);
        span.addEventListener('animationend', () => span.remove());
      }, { passive: true });
    }
    attachRipple(btnRunProbe);
    keybindsClose.addEventListener('click', hideKeybinds);
    aboutOverlay.addEventListener('click', (e) => {
      if (e.target === aboutOverlay) hideAbout();
    });
    keybindsOverlay.addEventListener('click', (e) => {
      if (e.target === keybindsOverlay) hideKeybinds();
    });
    document.addEventListener('keydown', (e) => {
      // modal close
      if (e.key === 'Escape' && aboutOverlay.classList.contains('active')) {
        hideAbout();
      }
      if (e.key === 'Escape' && keybindsOverlay.classList.contains('active')) {
        hideKeybinds();
      }
      // Ctrl+Enter => Run Probe
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        e.preventDefault();
        if (!btnRunProbe.disabled) {
          btnRunProbe.click();
        }
      }
      // Ctrl+L => focus endpoint input
      if ((e.ctrlKey || e.metaKey) && (e.key === 'l' || e.key === 'L')) {
        e.preventDefault();
        const ep = document.getElementById('endpointUrl');
        if (ep) ep.focus();
      }
      // Ctrl+/ => open keybinds
      if ((e.ctrlKey || e.metaKey) && e.key === '/') {
        e.preventDefault();
        showKeybinds();
      }
      // Theme hotkeys
      if ((e.ctrlKey || e.metaKey) && e.altKey && (e.key === 'l' || e.key === 'L')) {
        e.preventDefault();
        applyTheme('light');
        // Notify main process to sync menu
        if (window.electronAPI && window.electronAPI.themeReady) {
          window.electronAPI.themeReady({ theme: 'light' });
        }
      }
      if ((e.ctrlKey || e.metaKey) && e.altKey && (e.key === 'd' || e.key === 'D')) {
        e.preventDefault();
        applyTheme('dark');
        // Notify main process to sync menu
        if (window.electronAPI && window.electronAPI.themeReady) {
          window.electronAPI.themeReady({ theme: 'dark' });
        }
      }
    });

    // Optimized DOM updates: use DocumentFragment for batch inserts
    function ensureSection(id, titleText) {
      let header = document.getElementById(id);
      if (!header) {
        header = document.createElement('h4');
        header.className = 'category-title';
        header.id = id;
        header.textContent = titleText;
        resultsList.insertBefore(header, resultsList.firstChild);
      }
      return header;
    }
    
    function prependItem(sectionHeader, status, title, detail) {
      const item = document.createElement('div');
      item.className = `result-item ${status}`;
      // Use textContent for better performance and security (prevents XSS)
      const strong = document.createElement('strong');
      strong.textContent = title;
      const span = document.createElement('span');
      span.textContent = detail;
      item.appendChild(strong);
      item.appendChild(span);
      
      // Insert directly after section header for better performance
      const nextSibling = sectionHeader.nextSibling;
      if (nextSibling) {
        resultsList.insertBefore(item, nextSibling);
      } else {
        resultsList.appendChild(item);
      }
      resultsSection.classList.add('active');
    }

    // Prevent duplicate probe submissions
    let isProbeRunning = false;
    
    probeForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      // Prevent duplicate submissions
      if (isProbeRunning || btnRunProbe.disabled) {
        return;
      }
      
      isProbeRunning = true;
      btnRunProbe.disabled = true;

      // show determinate progress bar
      startProgressUI();

      resultsList.innerHTML = '';
      logInfo.textContent = '';
      resultsSection.classList.remove('active');
      try {
        const endpointUrl = document.getElementById('endpointUrl').value.trim();
        const systemBHost = document.getElementById('systemBHost').value.trim();
        const synSeconds = parseInt(document.getElementById('synSeconds').value) || 0;
        const nodeId = document.getElementById('nodeId').value.trim();
        const pubInterval = parseInt(document.getElementById('pubInterval').value) || 250;
        const params = {
          endpointUrl,
          systemBHost: systemBHost || undefined,
          synMonitorSeconds: synSeconds,
          publishIntervalMs: pubInterval
        };
        if (nodeId) params.nodeId = nodeId;

        const res = await window.electronAPI.runOpcuaProbe(params);
        const { probe, logFileName } = res || {};

        if (probe && probe.error) {
          alert('Probe error: ' + probe.error);
        }

        // Endpoint Security
        const secSec = ensureSection('securitySection', 'Endpoint Security');
        if (probe && probe.security) {
          const adv = probe.security.advertisedAnonymous;
          prependItem(secSec, adv ? 'open' : 'closed', 'Anonymous advertised', adv ? 'Yes' : 'No');
          // Negotiated channel (actual connection)
          if (probe.security.negotiatedChannel && (probe.security.negotiatedChannel.securityMode || probe.security.negotiatedChannel.securityPolicyUri)) {
            const ch = probe.security.negotiatedChannel;
            const policy = ch.securityPolicyUri || '(unknown)';
            const extra = (ch.policyShort || ch.classification) ? ` (${[ch.policyShort, ch.classification].filter(Boolean).join('; ')})` : '';
            prependItem(secSec, 'open', 'Negotiated channel', `mode=${ch.securityMode || '(unknown)'} policy=${policy}${extra}`);
            if (ch.serverCertificateSummary) {
              prependItem(secSec, 'open', 'Server certificate', ch.serverCertificateSummary);
            }
          }
          if (probe.security.endpointsQueried && Array.isArray(probe.security.anonymousEndpoints)) {
            if (probe.security.anonymousEndpoints.length) {
              probe.security.anonymousEndpoints.forEach((ed, idx) => {
                prependItem(secSec, 'open', `Anonymous endpoint [${idx + 1}]`, `${ed.endpointUrl} mode=${ed.securityMode} policy=${ed.securityPolicyUri}`);
              });
            }
          }
          // List all discovered endpoints with classification and tokens
          if (probe.security.endpointsQueried && Array.isArray(probe.security.allEndpoints) && probe.security.allEndpoints.length) {
            probe.security.allEndpoints.forEach((ed, idx) => {
              const extra = (ed.policyShort || ed.classification) ? ` (${[ed.policyShort, ed.classification].filter(Boolean).join('; ')})` : '';
              const tokens = Array.isArray(ed.userTokens) && ed.userTokens.length ? `; tokens=${ed.userTokens.join(', ')}` : '';
              prependItem(secSec, 'open', `Endpoint [${idx + 1}]`, `${ed.endpointUrl} mode=${ed.securityMode} policy=${ed.securityPolicyUri}${extra}${tokens}`);
            });
          }
          const anonSess = probe.security.anonymousSession || {};
          if (anonSess.success) {
            prependItem(secSec, 'open', 'Anonymous session', 'Succeeded');
          } else {
            const err = anonSess.error ? String(anonSess.error) : 'Failed';
            prependItem(secSec, 'closed', 'Anonymous session', err);
          }
        } else {
          prependItem(secSec, 'warning', 'Security info', 'Unavailable');
        }

        // Client callback info
        const cbSec = ensureSection('clientInfoSection', 'Client Callback Info');
        if (probe && probe.clientSocket) {
          prependItem(cbSec, 'open', 'Client local socket', `${probe.clientSocket.localAddress}:${probe.clientSocket.localPort}`);
          prependItem(cbSec, 'open', 'Server peer', `${probe.clientSocket.remoteAddress}:${probe.clientSocket.remotePort}`);
        } else {
          prependItem(cbSec, 'warning', 'Client local socket', 'Unavailable');
        }

        // Network interfaces
        const ifSec = ensureSection('interfacesSection', 'System A Network Interfaces');
        if (probe && probe.adapters && probe.adapters.length) {
          probe.adapters.forEach(a => {
            const addrs = (a.addresses || []).map(x => x.address).join(', ');
            prependItem(ifSec, 'open', a.name, addrs || '(no IPv4)');
          });
        } else {
          prependItem(ifSec, 'warning', 'No adapters found', '');
        }

        // Listeners before/after
        const lsSec = ensureSection('listenersSection', 'Process Listening Ports');
        const before = (probe && probe.listenersBefore) || [];
        if (!before.length) {
          prependItem(lsSec, 'warning', 'Before subscription', '(none)');
        } else {
          before.forEach(l => prependItem(lsSec, 'open', 'Before', `${l.localAddress}:${l.localPort} pid=${l.pid}`));
        }
        const after = (probe && probe.listenersAfter) || [];
        if (!after.length) {
          prependItem(lsSec, 'warning', 'After subscription', '(none)');
        } else {
          after.forEach(l => prependItem(lsSec, 'open', 'After', `${l.localAddress}:${l.localPort} pid=${l.pid}`));
        }

        // SYN monitor
        if (probe && probe.synMonitor && probe.synMonitor.enabled) {
          const synSec = ensureSection('synSection', 'Connection Attempt Logger');
          const m = probe.synMonitor.method || 'none';
          if (!probe.synMonitor.events || !probe.synMonitor.events.length) {
            prependItem(synSec, 'warning', `Method: ${m}`, 'No SYN attempts captured');
          } else {
            prependItem(synSec, 'open', `Method: ${m}`, `${probe.synMonitor.events.length} event(s)`);
            probe.synMonitor.events.forEach(ev => {
              prependItem(synSec, 'open', `[${ev.timestamp}]`, `${ev.src}:${ev.srcPort} -> ${ev.dst}:${ev.dstPort} syn=${ev.syn} ack=${ev.ack ? '1' : '0'}`);
            });
          }
        }

        // Log info
        if (res && res.logFileName) {
          logInfo.innerHTML = `
            <strong>ðŸ“„ Probe Log Saved</strong>
            Log file: ${res.logFileName}<br>
            Location: Application logs folder
          `;
        }

      } catch (err) {
        alert('Probe error: ' + (err && err.message ? err.message : String(err)));
        // fallback progress update if backend couldn't report failure
        setProgress(100, 'Failed');
        setCurrentTask('Failed.');
      } finally {
        stopProgressUI(); // Clean up progress
        isProbeRunning = false;
        btnRunProbe.disabled = false;
        if (btnRunProbe) {
          btnRunProbe.classList.remove('progressing');
          if (btnOriginalHtml) btnRunProbe.innerHTML = btnOriginalHtml;
        }
        // Clean up task update timeout
        if (taskUpdateTimeout) {
          clearTimeout(taskUpdateTimeout);
          taskUpdateTimeout = null;
        }
      }
    });
  </script>
</body>
</html>

